QL_statement ::= select_statement | update_statement | delete_statement 
select_statement ::= select_clause from_clause [where_clause] [groupby_clause] [having_clause] [orderby_clause] 
update_statement ::= update_clause [where_clause] 
delete_statement ::= delete_clause [where_clause] 
from_clause ::= FROM identification_variable_declaration {, {identification_variable_declaration | collection_member_declaration}}* 
identification_variable_declaration ::= range_variable_declaration { join | fetch_join }*
range_variable_declaration ::= abstract_schema_name [AS] identification_variable 
join ::= join_spec join_association_path_expression [AS] identification_variable  
fetch_join ::= join_spec FETCH join_association_path_expression 
join_association_path_expression ::= join_collection_valued_path_expression | join_single_valued_association_path_expression  
join_spec ::= [ LEFT [OUTER] | INNER ] JOIN
collection_member_declaration ::= IN (collection_valued_path_expression) [AS] identification_variable  
range_variable_declaration ::= abstract_schema_name [AS] identification_variable 
single_valued_path_expression ::= state_field_path_expression | single_valued_association_path_expression 
state_field_path_expression ::= {identification_variable | single_valued_association_path_expression}.state_field 
single_valued_association_path_expression ::= identification_variable.{single_valued_association_field.}*single_valued_association_field  
collection_valued_path_expression ::= identification_variable.{single_valued_association_field.}*collection_valued_association_field 
state_field ::= {embedded_class_state_field.}*simple_state_field 
join ::= join_spec join_association_path_expression [AS] identification_variable 
fetch_join ::= join_spec FETCH join_association_path_expression 
join_association_path_expression ::= join_collection_valued_path_expression | join_single_valued_association_path_expression 
join_spec ::= [ LEFT [OUTER] | INNER ] JOIN 
fetch_join ::= [ LEFT [OUTER] | INNER ] JOIN FETCH join_association_path_expression  
collection_member_declaration ::= IN (collection_valued_path_expression) [AS] identification_variable 
where_clause ::= WHERE conditional_expression 
having_clause ::= HAVING conditional_expression 
conditional_expression ::= conditional_term | conditional_expression OR conditional_term 
conditional_term ::= conditional_factor | conditional_term AND conditional_factor 
conditional_factor ::= [ NOT ] conditional_primary 
conditional_primary ::= simple_cond_expression | (conditional_expression) 
simple_cond_expression ::= comparison_expression | between_expression | like_expression | in_expression | null_comparison_expression | empty_collection_comparison_expression | collection_member_expression | exists_expression
in_expression ::= state_field_path_expression [NOT] IN ( in_item {, in_item}* | subquery) 
in_item ::= literal | input_parameter
collection_member_expression ::= entity_expression [NOT] MEMBER [OF] collection_valued_path_expression
entity_expression ::= single_valued_association_path_expression | simple_entity_expression 
simple_entity_expression ::= identification_variable | input_parameter
exists_expression ::= [NOT] EXISTS (subquery)
all_or_any_expression ::= { ALL | ANY | SOME} (subquery)
subquery ::= simple_select_clause subquery_from_clause [where_clause] [groupby_clause] [having_clause] 
simple_select_clause ::= SELECT [DISTINCT] simple_select_expression 
subquery_from_clause ::= FROM subselect_identification_variable_declaration {, subselect_identification_variable_declaration}*
subselect_identification_variable_declaration ::= identification_variable_declaration | association_path_expression [AS] identification_variable | collection_member_declaration
simple_select_expression ::= single_valued_path_expression | aggregate_expression | identification_variable
functions_returning_strings ::= CONCAT(string_primar y, string_primary) | SUBSTRING(string_primar y, simple_arithmetic_expression, simple_arithmetic_expression) | TRIM([[trim_specification] [trim_character] FROM] string_primary) | LOWER(string_primar y) | UPPER(string_primar y) 
trim_specification ::= LEADING | TRAILING | BOTH
functions_returning_numerics ::= LENGTH(string_primar y) | LOCATE(string_primar y, string_primar y[, simple_arithmetic_expression])
functions_returning_numerics ::= ABS(simple_arithmetic_expression) | SQRT(simple_arithmetic_expression) | MOD(simple_arithmetic_expression, simple_arithmetic_expression) | SIZE(collection_valued_path_expression)
groupby_clause ::= GROUP BY groupby_item {, groupby_item}* 
groupby_item ::= single_valued_path_expression | identification_variable 
having_clause ::= HAVING conditional_expression
select_clause ::= SELECT [DISTINCT] select_expression {, select_expression}* 
select_expression ::= single_valued_path_expression | aggregate_expression | identification_variable | OBJECT(identification_variable) | constructor_expression
constructor_expression ::= NEW constructor_name ( constructor_item {, constructor_item}* )
constructor_item ::= single_valued_path_expression | aggregate_expression 
aggregate_expression ::= { AVG | MAX | MIN | SUM } ([DISTINCT] state_field_path_expression) | COUNT ([DISTINCT] identification_variable | state_field_path_expression | single_valued_association_path_expression)
orderby_clause ::= ORDER BY orderby_item {, orderby_item}*
orderby_item ::= state_field_path_expression [ASC | DESC]
update_statement ::= update_clause [where_clause] 
update_clause ::= UPDATE abstract_schema_name [[AS] identification_variable] SET update_item {, update_item}* 
update_item ::= [identification_variable.]{state_field | single_valued_association_field} = new_value 
new_value ::= simple_arithmetic_expression | string_primary | datetime_primary | boolean_primary | enum_primary simple_entity_expression | NULL
delete_statement ::= delete_clause [where_clause] 
delete_clause ::= DELETE FROM abstract_schema_name [[AS] identification_variable]
